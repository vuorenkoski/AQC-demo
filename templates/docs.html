{% load static %}

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>AQC - Documentation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="{% static 'bootstrap.min.css' %}"/>
    <script src="{% static 'bootstrap.bundle.min.js' %}"></script>
    <link rel="stylesheet" type="text/css" href="{% static 'styles.css' %}" />
  </head>

  <body>
    <div class="container-fluid">
      <div class="row bg-color">
        <div class="col-sm-1">
          <br /><br /><br />
          <a class="mp" href="/"><p>Main Page</p></a>
          <a class="mp" href="/apsp"><p>All pairs shortest path</p></a>
          <a class="mp" href="/gi"><p>Graph isomorphism</p></a>
          <a class="mp" href="/cd"><p>Community detection</p></a>
          <a class="mp" href="/docs"><p>Documentation</p></a>
        </div>
        <div class="col-sm-11 mt-3">
          <div class="row m-1">
            <div class="col-sm-12">
              <h1>AQC - Documentation</h1>
            </div>
          </div>
          <div class="row m-0">
            <div class="col-sm-9 text-box rounded-top p-3">
              <p>This demo presents algorithms for solving certain graph problems using quantum annealer computer. Each problem is converted to QUBO which is then solved with three different type of D-Wave solvers: local simulator, quantum solver and hybrid solver. </p>
              <p>More information on the algorithms and implementation: <a href="http://urn.fi/URN:NBN:fi:hulib-202403131494" target="_blank">http://urn.fi/URN:NBN:fi:hulib-202403131494</a></p>
              <h2>Graph problems</h2>
              <ul>
                <li>In all pairs shortest path problem task is to find path with minimum sum of weights for every 
                  pair of vertices in graph.</li>
                <li>Graph isomorphism problem answers to the question are two graphs isomorphic. Two graphs are isomorphic if they have same
                  structure, meaning that vertices from one graph can be mapped to vertices of the other graph so that
                  vertices have the same connectivity.</li>
                  <li>Community detection algorithm identifies communities from graphs, so that edges between vertices in the same community would be maximised and edges between vertices in different communities would be minimised.</li>
              </ul>
              <h2>Graphs</h2>
              <p>Performance can be measured with variable types of graphs:</p>
              <ul>
                <li>
                  Path graph: a graph that can be drawn so that all of its vertices and edges lie on a single straight line.
                </li>
                <li>
                  Star graph: a graph that has n-1 edges from a single vertex to all other vertices.
                </li>
                <li>
                  Cycle graph: a graph in which all vertices and edges form a single cycle.
                </li>
                <li>Complete graph: a graph having all possible edges.</li>
                <li>
                  Tree graph: a graph in which any two vertices are connected by exactly one path (here balanced binary tree is used).
                </li>
                <li>
                  Graph with single cycle: a graph in which part of the vertices and edges form a single cycle (here balanced binary tree with an additional edge from the last leaf to the index vertex is used).
                </li>
                <li>
                  Graph with multiple cycles: a graph having multiple cycles (here balanced binary tree with with additional edges from every second leaf to the index vertex is used).
                </li>
                <li>
                  Bipartite graph: a graph in which vertices can be divided in two sets so that all edges are between these two sets (here vertices are divided into even and odd vertices so that there are 2-4 edges from every even vertex to odd vertices).
                </li>
                <li>
                  Wheel graph: a graph formed by connecting one vertex to all other vertices which together form a cycle.
                </li>
                <li>
                  Random graph: Random Erdos-Renyi (binomial) graph is constructed by NetworkX gnp_random_graph function with probability for edge creation 0.3 and seed 42. Each edge has random weight 1...10.
                </li>
                <li>
                  Community graph: Vertices are divided into three (almost) equal-size groups. Every group is itself a complete subgraph in which each edge has a weight of 5. Two vertices from each group are connected (weight of 1) to two vertices in all other groups.  
                </li>
              </ul>
              <p>For each of these graph types different size of graphs can be selected.</p>
              <h2>D-wave documentation</h2>
              <ul>
                <li>D-wave Leap: <a href="https://docs.dwavesys.com/docs/latest/guides_leap.html" target="_blank">https://docs.dwavesys.com/docs/latest/guides_leap.html</a></li>
                <li>D-wave solvers: <a href="https://docs.dwavesys.com/docs/latest/guides_solvers.html" target="_blank">https://docs.dwavesys.com/docs/latest/guides_solvers.html</a></li>
              </ul>
              <br /><br /><br />
            </div>
          </div>
          <div class="row">
            <footer class="py-4 text-center">
              <p>Lauri Vuorenkoski & Valter Uotila, 2023</p>
            </footer>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
