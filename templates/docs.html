{% load static %}

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>AQC - Documentation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="{% static 'bootstrap.min.css' %}"/>
    <script src="{% static 'bootstrap.bundle.min.js' %}"></script>
    <link rel="stylesheet" type="text/css" href="{% static 'styles.css' %}" />
  </head>

  <body>
    <div class="container-fluid">
      <div class="row bg-color">
        <div class="col-sm-1">
          <br /><br /><br />
          <a class="mp" href="/"><p>Main Page</p></a>
          <a class="mp" href="/apsp"><p>All pairs shortest path</p></a>
          <a class="mp" href="/gi"><p>Graph isomorphism</p></a>
          <a class="mp" href="/cd"><p>Community detection</p></a>
          <a class="mp" href="/docs"><p>Documentation</p></a>
        </div>
        <div class="col-sm-11 mt-3">
          <div class="row m-1">
            <div class="col-sm-12">
              <h1>AQC - Documentation</h1>
            </div>
          </div>
          <div class="row m-0">
            <div class="col-sm-9 text-box rounded-top p-3">
              <p>This demo presents algorithms for solving certain graph problems using quantum annealer computer. Each problems are converted to QUBO which is then solved with three different type of D-Wave solvers: local simulator, quantum solver and hybrid solver. </p>
              <h2>Graph problems</h2>
              <ul>
                <li>In all pairs shortest path problem task is to find path with minimum sum of weights for every 
                  pair of vertices in graph.</li>
                <li>Graph isomrphism problem answers to the qustion are two graphs isomorphic. Two graphs are isomorphic if they have same
                  structure, so that vertices from one graph can be mapped to vertices of the other graph so that
                  vertices have the same connectivity.</li>
                  <li>Community detection algorithm identifies communities from graphs, so that edges between vertices in the same community would be maximised and edges between vertices in different communities would be minimised.</li>
              </ul>
              <h2>Graphs</h2>
              <p>Performance can be measured with variable types of graphs:</p>
              <ul>
                <li>
                  Path graph: graph that can be drawn so that all of its
                  vertices and edges lie on a single straight line
                </li>
                <li>
                  Star graph: graph that have n-1 edges from single vertex to
                  all other vertices/li>
                </li>
                <li>
                  Cycle graph: graph in which all vertices form single cycle.
                </li>
                <li>Complete graph: graph having all possible edges</li>
                <li>
                  Tree graph: graph in which any two vertices are connected by
                  exactly one path (here balanced binary tree is used).
                </li>
                <li>
                  Graph with single cycle: graph in which part of the vertices
                  and edges form a single cycle (here balanced binary tree with
                  an edge from last leaf to the index vertex is used).
                </li>
                <li>
                  Graph with multiple cycles: graph having multiple cycles (here
                  balanced binary tree with with edges from every second leaf to
                  the index vertex is used)./li>
                </li>
                <li>
                  Bipartite graph: graph which vertices can be divided in two
                  sets so that all edges are between these two sets (here
                  vertices are divided to even and odd vertices so that there
                  are 2-4 edges from every even vertex to odd vertices).
                </li>
                <li>
                  Wheel graph: graph formed by connecting one vertex to all
                  other vertices which together form a cycle.
                </li>
                <li>
                  Random graph: Random Erdos-Renyi (binomial) graph is
                  constructed by NetworkX gnp_random_graph function with
                  probability for edge creation 0.3 and seed 42. Each edge has
                  random weight 1...10.
                </li>
                <li>
                  Community graph: Vertices are divided to three (almost) equal
                  size groups. Every group is itself a complete subgraph having
                  weight of 5 edges. Two vertices from each group are connected
                  (weight of 1) to two vertices in all other groups.
                </li>
              </ul>
              <p>For each of these graph types different size of graphs can be selected.</p>
              <br /><br /><br />
            </div>
          </div>
          <div class="row">
            <footer class="py-4 text-center">
              <p>Lauri Vuorenkoski & Valter Uotila, 2023</p>
            </footer>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
